\chapter*{Wstęp}
\addcontentsline{toc}{chapter}{Wstęp}
\chapter{Wprowadzenie do problematyki}
\chapter{Technologie i narzędzia wykorzystywane w pracy}
W poniższym rozdziale zostały opisane wybrane technologie oraz narzędzia deweloperskie, wspomagające zapewnienie jakości kodu, wykorzystywane w trakcie implementacji systemu.
\section{Xamarin.Android}
\label{sec:xamAnd}
Xamarin.Android jest to platforma programistyczna, stworzona w oparciu o \textit{.NET Framework}, do tworzenia aplikacji na system operacyjny Android z wykorzystaniem natywnych metod SDK (\textit{Software Development Kit}) systemu Android. Z pomocą wyżej wymienionej platformy, aplikacje są tworzone w języku C\# , co w połączeniu z implementacją Xamarin.Android, daje możliwość wykorzystywania specyficznych cech języka takich jak np. \textit{LINQ}. 

Kod źródłowy w C\#, w celu uzyskania natywnej aplikacji, jest kompilowany do IL (\textit{Common Intermediate Language}) z wykorzystaniem kompilatora MonoVM. MonoVM jest kompilatorem typu JIT (\textit{just-in-time compiler}). Program jest kompilowany w trakcie wykonywania, przed wykonaniem  danego fragmentu kodu, do kodu maszynowego.
Niewykorzystane klasy zawarte w frameworku są podczas kompilowania aplikacji usuwane z wykorzystaniem \textit{linkera}, w celu zmniejszenia rozmiaru aplikacji.\cite{RefWorks:3} \cite{Part1–Un34:online} \cite{Linkingo58:online} 

Aplikacja działa obok natywnych aplikacjami (napisanymi w językach Java/Kotlin) w ART (\textit{Android Runtime} - środowisko uruchomieniowe systemu Android). Interakcje z wykorzystaniem natywnych typów odbywają się z pomocą JNI (\textit{Java Native Interface}) \cite{Part1–Un34:online}

\section{Xamarin.iOS}
\label{sec:xamiOS}
Xamarin.iOS, podobnie jak wspomniany w poprzednim podrozdziale Xamarin.Android, jest to platforma programistyczna, stworzona w oparciu o .NET Framework, do tworzenia aplikacji na system operacyjny iOS. Wykorzystuje ona natywne metody SDK (\textit{Software Development Kit}) systemu iOS. Aplikacje są tworzone z wykorzystaniem języka C\#.

Kod źródłowy jest kompilowany z użyciem kompilacji AOT (\textit{Ahead-Of-Time}) do języka assemblera dla procesorów ARM. Do kodu jest dołączony framework .NET, którego nieużywane klasy są usuwane przy pomocy \textit{linkera} w celu zmniejszenia rozmiaru aplikacji.\cite{RefWorks:4} \cite{Part1–Un34:online} \cite{Linkingo42:online}

Jako, że firma Apple - twórca systemu iOS, nie pozwala na dynamiczne generowanie kodu w trakcie wykonywania programu, niektóre cechy języka C\# nie są dostępne dla twórcy aplikacji. (ograniczenia głównie dotyczą klas generycznych \cite{Limitati57:online} oraz mechanizmu refleksji \cite{Limitati74:online})
\section{ASP.NET Core}
\label{sec:aspCore}
ASP.NET Core jest to wieloplatformowy, otwarty framework, stworzony przez firmę Microsoft, służący do budowania nowoczesnych aplikacji internetowych. Umożliwia on między innymi budowanie aplikacji oraz serwisów internetowych czy też aplikacji działąjących na urządzeniach IoT \textit{Internet of Things}.

Z racji wieloplatformowości, aplikacje mogą być tworzone oraz uruchamiane na systemach z rodziny Windows, Linux oraz macOS. Jako środowisko uruchomieniowe wykorzystywany jest .NET Framework (Windows) lub .NET Core (Windows/Linux/macOS) \cite{Introduc95:online}
 

\section{Entity Framework Core}
\label{sec:entityCore}
Entity Framework (EF) Core jest to wieloplatformowy ORM (\textit{Object-Relational Mapper} - mapper obiektowo-relacyjny) zbudowany przez firmę Microsoft w oparciu o .NET Core, umożliwiający pracę z relacyjną bazą danych z wykorzystaniem natywnych obiektów ze środowiska .NET.

EF Core prawie całkowicie eliminuje konieczność tworzenia ręcznie zapytań SQL do bazy danych. Można z niego korzystać z wieloma silnikami bazodanowymi np. \textit{Microsoft SQL Server}, \textit{Oracle}.

Z wykorzystaniem EF Core, dostęp do danych odbywa się za pośrednictwem modelu. Model składa się z klas opisujących modele związków encji oraz kontekstu, który reprezentuje sesję połączenia z bazą danych, umożliwiając tworzenie zapytań oraz zapisywanie danych.

EF Core umożliwia wygenerowanie modelu na podstawie istniejącej bazy danych (podejście \textit{Database-First}) lub wygenerowanie bazy danych na podstawie przygotowanego modelu z wykorzystaniem mechanizmu migracji (podejście \textit{Code-First})\cite{QuickOve99:online}

\section{Dapper}
\label{sec:dapper}
Dapper jest to otwarty (\textit{open-source}) ORM (\textit{Object-Relational Mapper} - mapper obiektowo-relacyjny). Określa się go czasami również jako microORM, ze względu na brak wszystkich funkcjonalności charakteryzujących klasyczne ORM-y takie jak np. opisany w poprzednim podrozdziale Entity Framework Core [\ref{sec:entityCore}]. 

Zaletą Dapper-a jest znacznie mniejszy narzut wydajnościowy, co można zauważyć przy odczycie danych. W porównaniu z Entity Framework, Dapper przy odczycie danych potrafi być ponad 10 razy szybszy (dane dla 500 operacji SELECT).

Od strony technicznej Dapper jako biblioteką rozszerzającą interfejs \textit{IDbConnection} dostępny w ramach .NET Framework. Dzięki takiej implementacji, Dapper zapewnia podobną wydajność jak ręczne mapowanie danych z wykorzystaniem klasy \textit{SqlDataReader} \cite{StackExc69:online}  
\section{MVVMCross}
\label{sec:mvvmCross}
MVVMCross jest to otwarty (\textit{open-source}) framework wspomagający tworzenie aplikacji według wzorca architektonicznego Model-View-ViewModel. MVVMCross jest przygotowany specjalnie pod kątem platformy Xamarin. Wspiera tworzenie aplikacji w technologiach Xamarin.Android, Xamarin.iOS, Xamarin Forms, Universal Windows Platform (UWP) oraz Windows Presentation Framework (WPF).

Do głównych funkcjonalności MVVMCross należą: wsparcie dla wzorca MVVM, system nawigacji, \textit{data binding}, wsparcie dla specyficznych dla danej platformy funkcji, wbudowany system wstrzykiwania zależności \textit{Dependency Injection} oraz odwracania kontroli \textit{Inversion of Control}, system pluginów dla najczęściej wykorzystywanych funkcji oraz wsparcie dla testów jednostkowych. \cite{GettingS94:online}

Dzięki wykorzystaniu MVVM Cross, można współdzielić nawet do 90\% kodu pomiędzy aplikacjami na różne platformy.
\section{Team Foundation Server}
\label{sec:team}
Team Foundation Server jest to system firmy Microsoft wspierający zarządzanie projektem informatycznym przez cały cykl życia oprogramowania.
Do jego funkcjonalności zaliczamy:
\begin{itemize}
\item system kontroli wersji/repozytorium kodu (do wyboru Git lub Team Foundation Version Control)\cite{Kontrola99:online},
\item wsparcie przy planowaniu prac w zespołach projektowych w zespołach korystających z metodyk zwinnych (Agile/Scrum) oraz modelu kaskadowego (\textit{waterfall})\cite{Narzedzi82:online},
\item \textit{DevOps} - automatyzacja procesu wytwarzania oprogramowania w celu zapewnienia jakości - automatyczne budowanie aplikacji, uruchamianie testów, dostarczanie metryk dotyczących kodu (np. \textit{Code Coverage} - pokrycie kodu testami lub ocena długu technologicznego), automatyczne wdrażanie aplikacji, wsparcie dla wielu środowisk wdrożeniowych, system zarządzania wydaniami\cite{Ciaglain95:online}
\item wsparcie dla wielu języków programowania oraz obsługa serwerów budujących z systemami Windows, Linux oraz macOS \cite{Buildand77:online}
\item Integracja z zewnętrznymi narzędziami: np. środowiskami programistycznymi (takimi jak np. Visual Studio lub Eclipse), platformami typu Visual Studio Mobile Center (więcej w podrozdziale \ref{sec:hockeyapp})
\end{itemize}
\section{Microsoft Azure}
\label{sec:azure}
Microsoft Azure jest to usługa chmury obliczeniowej stworzona przez firmę Microsoft, służąca do tworzenia, testowania, wdrażania i zarządzania aplikacji oraz serwisów znajdujących się w centrach danych firmy Microsoft.

Microsoft Azure udostępnia usługi w modelach IaaS (\textit{Infrastructure as a Service}), PaaS (\textit{Platform as a Service}) oraz SaaS (\textit{Service as a Service}). Wspiera różne języki programowania, narzędzia oraz frameworki, zarówno stworzone przez Microsoft jak i firm trzecich. 
\newpage
Do najpopularniejszych usług należą między innymi:
\begin{itemize}
\item maszyny wirtualne (IaaS) pozwalające na uruchomienie obrazów systemów Windows oraz Linux
\item \textit{App Service} udostępniany jako usługa w modelu PaaS umożliwia hostowanie aplikacji internetowych oraz mobilnych stworzonych w różnych technologiach. Umożliwia integrację z instancją Team Foundation Server (podrozdział \ref{sec:team}) w ramach ciągłej integracji oraz ciągłego wdrażania.
\item baza danych SQL działająca w technologii Microsoft SQL Server.
\end{itemize}
\section{Visual Studio Mobile Center}
\label{sec:hockeyapp}
Visual Studio Mobile Center jest to platforma deweloperska działająca w chmurze stworzona przez firmę Microsoft. Do głównych usług oferowanych należą:
\begin{itemize}
\item po podpięciu repozytorium kodu z usługi Team Foundation Server - możliwość budowania aplikacji mobilnych,
\item możliwość testowania aplikacji na podstawie testów interfejsu przygotowanych z wykorzystaniem różnych framework'ów (np. Xamarin UI Tests)
\item możliwość dystrybucji aplikacji wśród zamkniętej grupy użytkowników (umożliwia prowadzenie zamkniętych testów aplikacji)
\item gromadzenie informacji o błędach aplikacji
\item gromadzenie statystyk użycia aplikacji - informacje o zachowaniach użytkowników, urządzeniach na których działa aplikacja, zdarzeniach w trakcie działania aplikacji
\end{itemize}
\chapter{Założenia projektowe}
W tym rozdziale zostaną omówione założenia projektowe systemu. Pierwszy podrozdział jest poświęcony opisowi przedmiotu pracy. W podrozdziałach drugim oraz trzecim zostały opisane wymagania (odpowiednio funkcjonalne i niefunkcjonalne) na system. Ostatni podrozdział jest to opis zaprojektowanej architektury systemu.
\section{Przedmiot pracy}
Przedmiotem pracy jest utworzenie aplikacji mobilnej na platformy Android oraz iOS, umożliwiającej rezerwację i zakup biletów kinowych w ramach sieci kin, wraz z towarzyszącą aplikacją serwerową. Aplikacja kliencka będzie utworzona w oparciu o platformę Xamarin [\ref{sec:xamAnd}][\ref{sec:xamiOS}], natomiast aplikacja serwerowa w oparciu o framework ASP.NET Core [\ref{sec:aspCore}]
\section{Wymagania funkcjonalne}
System powinien spełniać następujące wymagania funkcjonalne. Przy definiowaniu wymagań przyjęto następujących aktorów - Klient, Pracownik kina, Administrator systemu, System 
\begin{enumerate}
\item Jako Klient, chcę mieć możliwość stworzenia konta użytkownika na podstawie adresu e-mail, w celu zachowania preferencji użytkownika pomiędzy urządzeniami.
\item Jako Klient, chcę mieć możliwość stworzenia konta użytkownika z wykorzystaniem konta w jednym ze wspieranych portali społecznościowych (Facebook, Twitter, Google), w celu przyspieszenia procesu tworzenia konta.
\item Jako Klient, chcę mieć możliwość modyfikacji informacji o koncie użytkownika, w celu wygodnej aktualizacji danych.
\item Jako Klient, chcę mieć możliwość zresetowania hasła do konta użytkownika, w celu odzyskania dostępu do konta. 
\item Jako Klient, chcę mieć możliwość wyboru domyślnego kina, w celu łatwiejszego dostępu do aktualnego repertuaru.
\item Jako Klient, chcę mieć możliwość przeglądania aktualnego repertuaru w danym kinie, w celu zapoznania się z ofertą kina.
\item Jako Klient, chcę mieć możliwość przeglądania podstawowych informacji o filmie z repertuaru, w celu zapoznania się z krótkim opisem filmu. 
\item Jako Klient, chcę mieć możliwość złożenia rezerwacji biletu(ów) na wybrany seans w wybranym kinie, w celu późniejszej finalizacji zamówienia przed seansem.
\item System anuluje wszystkie niepotwierdzone rezerwacje 30 minut przed planowanym początkiem seansu. 
\item Jako Klient, chcę mieć możliwość zakupu biletu(ów) na wybrany seans w wybranym kinie, w celu braku konieczności kupna biletu w kasie stacjonarnej przed seansem.
\item Jako Klient, chcę mieć możliwość dokonania zapłaty za zakupione bilety za pośrednictwem zewnętrznego systemu płatności elektronicznych, w celu szybszej finalizacji zamówienia
\item Jako Klient, chcę mieć możliwość zwrotu zakupionych biletów do 3 godzin przed planowanym seansem, w celu odzyskania pieniędzy za niewykorzystane bilety.
\item Jako Klient, chcę mieć możliwość wyboru miejsc na podstawie widoku sali kinowej, w celu świadomego wyboru miejsca na sali kinowej.
\item Jako Klient, chcę mieć możliwość wyboru rodzaju biletu przy wyborze miejsc, w celu wyboru odpowiedniego rodzaju biletu (np. ulgowego dla osoby niepełnoletniej).
\item Jako Klient, chcę mieć możliwość przeglądania historii rezerwacji oraz zakupionych biletów, w celu   zapoznania się z poprzednimi transakcjami.
\item Jako Klient, chcę mieć możliwość dokonania zakupu biletu(ów) bez potrzeby zakładania konta, w celu szybkiego złożenia pojedynczego zamówienia.
\item Jako Klient, chcę mieć możliwość dokonania rezerwacji biletu(ów) bez potrzeby zakładania konta, w celu szybkiego złożenia pojedynczej rezerwacji
\item Jako Klient, chcę mieć możliwość okazania biletu w formacie kodu QR, w celu ułatwienia weryfikacji biletu przy wejściu na salę kinową.
\item Jako Klient, chcę mieć możliwość okazania biletu pomimo braku połączenia z siecią Internet, w celu ograniczenia powszechnych problemów dotyczących połączenia internetowego przy okazywaniu biletu.\newline
\item Jako Pracownik kina, chcę mieć możliwość modyfikacji podstawowych danych o kinie, w celu aktualizacji danych.
\item Jako Pracownik kina, chcę mieć możliwość modyfikacji informacji o salach dostępnych w kinie, w celu aktualizacji ilości dostępnych miejsc na sali kinowej.
\item Jako Pracownik kina, chcę mieć możliwość modyfikacji repertuaru kina, w celu aktualizacji oferty kina.
\item Jako Pracownik kina, chcę mieć możliwość potwierdzenia rezerwacji klienta, w celu finalizacji zamówienia.
\item Jako Pracownik kina, chcę mieć możliwość anulowania rezerwacji klienta, w celu zapewnienia większego wyboru miejsc dla pozostałych Klientów.
\item Jako Pracownik kina, chcę mieć możliwość dokonania sprzedaży biletów klientom w kasie biletowej, w celu umożliwienia kupna biletów przez Klientów nie posiadających aplikacji.
\item Jako Administrator systemu, chcę mieć możliwość dodawania, modyfikowania i usuwania informacji o kinach należących do sieci kin, w celu weryfikacji danych o kinach.
\item Jako Administrator systemu, chcę mieć możliwość tworzenia oraz modyfikacji kont użytkowników oraz przydzielania im ról, w celu zarządzania dostępu użytkowników do systemu.
\end{enumerate}
Powyższa lista jest pełnym zbiorem wymagań, które powinny się znaleźć w ostatecznej wersji systemu. Prototyp systemu, będący celem pracy, będzie miał zaimplementowane wszystkie funkcjonalności dotyczące roli Klienta tj. wymagania od pierwszego do dziewiętnastego.
\section{Wymagania niefunkcjonalne}
Zbiór tych wymagań definiuje, jakie wymagania na system mają zostać spełnione, oprócz wymagań funkcjonalnych. Wymagania te głównie dotyczą wydajności, bezpieczeństwa i tym podobnych aspektów.
\begin{enumerate}
\item System powinien być dostępny bez przerwy. (Dostępność na poziomie 99,9\%)
\item System jest w stanie obsługiwać wiele jednocześnie podłączonych urządzeń.
\item Do poprawnego korzystania ze wszystkich funkcji oferowanych przez aplikację, wymagane jest stałe połączenie internetowe.
\item W celu zapewnienia odpowiedniego poziomu bezpieczeństwa, połączenie między serwerem i klientem ma być szyfrowane.
\item System ma wspierać również mechanizm sesji, jako dodatkowy mechanizm zabezpieczający połączenie.
\item Aplikacja kliencka powinna być dostępna na systemach Android (w wersji 4.4 i wyższej) oraz iOS (w wersji 8.0 i wyższej).
\item Aplikacja kliencka powinna zostać uruchomiona na urządzeniu mobilnym niezależnie od stanu połączenia internetowego.
\item Aplikacja serwerowa powinna móc być uruchomiona na serwerach z systemami rodziny Windows Server (wersja 2012 R2 i wyżej) oraz Linux

\end{enumerate}
\section{Opis podstawowej architektury systemu}
\subsection*{Architektura logiczna}
System będzie składał się z trzech aplikacji. 

\par Pierwszą z nich jest aplikacja serwerowa, realizowana w architekturze trójwarstwowej (podział na warstwę prezentacji, logiki biznesowej oraz dostępu do danych). Dzięki takiemu podziałowi, w którym wyższa warstwa nie wie o logice zawartej w niższej warstwie (\textit{black box}) zapewniamy m.in. dużą skalowalność rozwiązania (każdą warstwę możemy skalować według potrzeb) oraz ułatwione testowanie rozwiązania poprzez brak skomplikowanych zależności pomiędzy warstwami.

\par Operacje na bazie danych aplikacji będą wykonywane w warstwie dostępu do danych z częściowym wykorzystaniem podejścia CQRS (\textit{Command Query Responsibility Segregation}), które zapewni jeszcze lepszą skalowalność rozwiązania poprzez, przede wszystkim oddzielenie operacji zapisu danych od ich odczytu. Więcej szczegółów na temat podejścia CQRS oraz jego implementacji znajduje się w podrozdziale~\ref{sec:cqrs}

\par Pozostałą część systemu stanowią aplikacje mobilne działająca pod kontrolą systemu Android oraz iOS. Aplikacje te będą implementowane z wykorzystaniem platformy Xamarin. Dzięki temu możemy mówić o aplikacji wieloplatformowej, ponieważ większość kodu aplikacji (głównie chodzi tutaj o logikę zawartą w aplikacji) jest współdzielona. Aby umożliwić współdzielenie kodu, będzie zastosowany wzorzec architektoniczny Model-View-ViewModel. Dzięki temu wzorcowi dokonujemy separacji aplikacji na warstwy: widoku (View), logiki interfejsu (ViewModel) oraz modelu danych. Logika interfejsu oraz modelu danych są współdzielone, natomiast osobne widoki odpowiadają specyfice poszczególnych systemów. Wyseparowane warstwy sprawiają, że kod aplikacji jest o wiele bardziej testowalny oraz łatwiejszy w utrzymaniu. Do przechowywania danych lokalnych aplikacji posłuży baza danych SQLite.

\subsection*{Architektura fizyczna}
Aplikacja serwerowa zbudowana będzie w oparciu o framework ASP.NET Core. Będzie mieć ona możliwość pracowania na serwerach z systemami rodziny Windows Server oraz Linux. Wykorzystywany serwer WWW to, w zależności od wybranego systemu, IIS (\textit{Internet Information Services}) oraz Apache.

\par Aplikacja serwerowa będzie komunikować się z serwerem bazodanowym Microsoft SQL Server znajdującym się na osobnym serwerze (działającym pod kontrolą dystrybucji systemu Windows Server lub Linux), z wykorzystaniem protokołu TLS/SSL w celu zapewnienia odpowiedniego poziomu bezpieczeństwa.

\par W ramach realizowanego prototypu, serwery aplikacji oraz bazy danych będą hostowane na platformie obliczeniowej Microsoft Azure. 

\par Aplikacje klienckie działające na urządzeniach z systemami Android oraz iOS, będą komunikowały się z serwerem aplikacji, wykorzystując udostępnione przez aplikację \textit{RESTful API}. Formatem przesyłanych danych jest \textit{JSON}. Komunikacja odbywa się za pośrednictwem protokołu HTTPS (ruch jest szyfrowany).
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{img1}
\caption{Architektura fizyczna systemu}
\end{figure}
\chapter{Projekt aplikacji}
\section{Przypadki użycia}
\section{Interfejs}
\section{Diagram klas}
\addtocontents{toc}{\protect\newpage}
\chapter{Implementacja}
W tym rozdziale zostały opisane najważniejsze aspekty dotyczące fazy implementacji. Pierwszy podrozdział opisuje wykorzystanie metodyki DevOps w celu zapewnienia jakości produktu końcowego. W drugim podrozdziale zawarte jest rozwiązanie problemu autoryzacji użytkowników aplikacji mobilnej. W dalszej części znajdują się: opis rozwiązania synchronizacji danych w trybie offline, opis zastosowanych technik mających na celu zapewnienie bezpieczeństwa aplikacji, sposób i cel wykorzystania wzorca CQRS (\textit{Command Query Responsibility Segregation}) oraz opis przeprowadzonych testów interfejsu użytkownika.
\section{DevOps}
DevOps (\textit{development and operations}) jest to sposób wytwarzania oprogrmowania, mający na celu ścisłą współpracę pomiędzy osobami (programistami) odpowiedzialnymi za rozwój oprogramowania, a osobami specjalizującymi się w utrzymywaniu rozwiązań IT (administratorzy). Dzięki ścisłej współpracy grup osób odpowiedzialnych za rozwój (\textit{development}), eksploatację (\textit{operations}) oraz zapewnienie jakości (\textit{quality assurance}), DevOps znacznie skraca czas wdrożenia nowych funkcji w oprogramowaniu. Temat DevOps został po raz pierwszy zaprezentowany w 2009 roku przez Patricka Debois w trakcie pierwszej konferencji DevOps Days w Belgii. \cite{RefWorks:2}\cite{Czymjest19:online}

Metoda DevOps jest obecnie wykorzystywana głównie przez firmy i organizacje, które wytwarzają i wdrażają dużą ilość zmian w swoim oprogramowaniu, działającym na środowiskach produkcyjnych przy zachowaniu jak najkrótszego czasu potrzebnego na wdrożenie oraz wysokiej jakości oprogramowania. \cite{Devopsco42:online}

Pojęcie DevOps jest ściśle powiązane z procesami takimi jak:
\begin{itemize}
\item Continuous Integration (ciągła integracja),
\item Continuous Delivery (ciągłe dostarczanie),
\item Continuous Testing (ciągłe testowanie),
\item Continuous Monitoring (ciągły monitoring) oraz
\item Continuous Deployment (ciągłe wdrażanie)
\end{itemize}
\newpage
Definiują one w klarowny sposób jakie procesy są realizowane w ramach metodyki DevOps. Innymi słowy, DevOps można przedstawić jako pewien rodzaj dyscypliny w budowie oraz weryfikacji wytwarzanego oprogramowania, za pośrednictwem testów regresji oraz statycznej analizy kodu zawartego w systemie kontroli wersji (pokrycie kodu testami, ocena długu technologicznego). To podejście jest jedną z najbardziej zwinnych praktyk rozwoju oprogramowania. Umożliwia opracowanie rozwiązań wysokiej jakości, zapewniając aktualną informację zwrotną na temat wad wytworzonego kodu. \cite{Devopsco42:online}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{img2}
\caption{Wizualizacja procesu wytwarzania oprogramowania w ramach metodyki DevOps}
\end{figure}

W procesie wytwarzania opisywanego systemu została wykorzystana opisana wyżej metodyka, w celu zapewnienia jakości oprogramowania. Do planowania prac został wykorzystany system Team Foundation Server wspierający podejście zwinne (\textit{Agile}) do prowadzenia projektu. (opisany w podrozdziale \ref{sec:team}). Zadania były definiowane jako historyjki użytkownika powstałe podczas tworzenia wymagań funkcjonalnych. Do każdego takiego zadania tworzono podzadania (ang. \textit{subtasks}) opisujące techniczne aspekty uzyskania danej funkcjonalności. W późniejszym etapie funkcjonowania systemu, TFS może być wykorzystywany do przechowywania informacji o zgłoszonych przez użytkowników (testerów oraz użytkowników końcowych) błędach oraz propozycjach zmian.

W kroku implementacji rozwiązania wykorzystano repozytoria systemu kontroli wersji Git, którego obsługę wbudowano w Team Foundation Server. W ramach projektu utworzono dwa repozytoria. Osobne dla aplikacji serwerowej oraz mobilnej. W ramach pracy nad konkretnymi funkcjonalnościami, wykorzystano mechanizmy oferowane przez wyżej wymieniony system kontroli wersji  m.in.: \textit{feature branches}, \textit{pull requests}. Ma to bardzo duże znaczenie w przypadku projektów zespołowych, pozwalajac na bezproblemowy, równoległy rozwój oprogramowania.

W następnym kroku następuje budowanie rozwiązania w ramach ciągłej integracji. Po wykonaniu zmian w repozytorium kodu (w głównej gałęzi - w branchu master) następuje automatyczne budowanie projektów na serwerze budującym działającym w chmurze Microsoft Azure jako maszyna wirtualna, opartym o system Windows Server 2016. Serwer budujący jest zintegrowany z systemem Team Foundation Server co umożliwia łatwe tworzenie definicji budowania. 

Po pomyślnie ukończonym procesie budowania rozwiązania, uruchamiane są testy jednostkowe oraz statyczna analiza kodu z wykorzystaniem NDepend. Dzięki temu natychmiast uzyskujemy statystyki dotyczące pokrycia kodu testami (ang. \textit{code coverage}) oraz prognozowanego długu technologicznego (ang. \textit{technical debt}).

W następnym kroku udostępniane są artefakty powstałe podczas procesu budowania oraz:
\begin{itemize}
\item w przypadku aplikacji serwerowej następuje wdrożenie aplikacji na środowisko deweloperskie utworzone w usłudze Microsoft Azure - po ukończeniu testów na środowisku deweloperskim, po ręcznym zaakceptowaniu przez uprawnionego użytkownika, następuje wdrożenie na środowiska \textit{staging} oraz produkcyjne
\item w przypadku aplikacji mobilnej następuje dystrybucja aplikacji do testerów w ramach systemu Visual Studio Mobile Center jako wersja alpha (więcej o VS Mobile Center w podrozdziale \ref{sec:hockeyapp}) - po ukończeniu testów wersji alpha, po ręcznym zaakceptowaniu przez uprawnionego użytkownika, następuje dystrbucja aplikacji w wersji beta dla szerszego grona testerów oraz wersji produkcyjnej do internetowych sklepów takich jak Google Play Store oraz Apple App Store
\end{itemize}

Do zbierania telemetrii aplikacji zastosowano usługi: Azure Application Insights dla aplikacji serwerowej oraz Visual Studio Mobile Center dla aplikacji mobilnych. Dzięki wyżej wymienionym usługom, mamy dostęp do wielu statystyk takich jak np.: średni czas odpowiedzi serwera, ilość żądań HTTP, czas uruchamiania aplikacji, statystyki dotyczące urządzeń korzystających z aplikacji, dane dotyczące wyjątków, które wystąpiły w trakcie działania aplikacji. Dzięki integracji z Team Foundation Server jest możliwe automatyczne tworzenie zgłoszeń o błędach w aplikacji na podstawie wystepujących wyjątków.
\section{Autoryzacja użytkowników aplikacji}
\section{Bezpieczeństwo aplikacji}
\section{Implementacja wzorca CQRS}
\label{sec:cqrs}
\section{Testy interfejsu aplikacji}
\chapter{Podsumowanie}
\printbibliography[nottype=misc, title={Bibliografia},resetnumbers=true,heading=bibintoc]
\begin{refcontext}[labelprefix=L]
\printbibliography[type=misc, title={Netografia},resetnumbers=true,heading=bibintoc]
\end{refcontext}
\chapter*{Załączniki}
\addcontentsline{toc}{chapter}{Załączniki}
\section*{Spis tabel}
\addcontentsline{toc}{section}{Spis tabel}
\listoftables
\section*{Spis rysunków}
\addcontentsline{toc}{section}{Spis rysunków}
\listoffigures
\lstlistoflistings
\addcontentsline{toc}{section}{Spis listingów}
\section*{Instrukcja kompilacji i testowego uruchomienia aplikacji}
\addcontentsline{toc}{section}{Instrukcja kompilacji i testowego uruchomienia aplikacji}